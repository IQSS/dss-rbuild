---
title: "Package Development in R"
author: "Asher Spector"
date: "March 2, 2018"
output: html_document
---

To do: 
1. Add in pictures
2. Add in examples of "general" coding comments
3. Add in documentation for data (also s3/s4 classes and reference classes?)
4. Overall and specific description of documentation

This page will walk you through the structure, motivation, and process of building packages in R. We'd like to extend a huge thank you to Hadley Wickham's book [R packages](http://r-pkgs.had.co.nz/r.html#r); this part of the guide is basically a condensed and simplified version of that book. A huge portion of the credit should go to him. 

## 1. Motivation

Imagine Grace has built an architecture for aggregating polling data, and you would like to use it in your own research project. So you go to github and you download Grace's repository, hoping to build on her research. One of the scripts you download looks like this. 

![*This is not what packages should look like*](Images/badexample.PNG)

When you read this script, you should notice at least a couple of problems.

First, upon reading this code, most programmers would have absolutely no idea what it's supposed to do. Because this is a simple example, you might be able to guess that the lm function returns the squared difference of its inputs, and the sqt function takes the square root of negative numbers. But the "scalep" function is almost totally incomprehensible - what's it supposed to do? 

Second, even if you could tell what the "scalep" function does, you'd have no idea how to use it, because you don't know how the "datapath.csv" csv file should be structured. 

Third, it's very difficult to use this script in combination with other packages. The "lm" function has the same name as the "lm" function from the R Stats package, which is incredibly useful, and very commonly used. Giving a new function the same name as a base function will create extremely weird bugs or just cause a fatal error and end your entire session. 

Lastly, and less obviously, you don't know what *version* of Grace's package this script is. Grace will probably update and modify her scripts over time, and unless you are aware of the contents of those changes, the script may behave differently than you expect.

Yet never fear - packages don't need to be this way! Most packages are extremely well-built and easy to use. In this section, we'll demonstrate how to make sure your packages are like those packages. 

## 2. Solutions

In this section, we'll discuss the solutions to the problems outlined above. For each problem, we'll discuss the conceptual solution, and then we'll describe how the structure of R Packages allows users to integrate those solutions. Note that this section mostly just outlines package structure - we won't talk about actually creating things like documentation until the next couple sections. 

### 2.1 Code Style

The first solution is to write code differently. The script above has a couple problems with style. Specifically, note the difference between the following two code samples:

```{r}
sqt <- function(x){
  if(x==0){return(x)}
  else if(x>0){return(sqrt(x))}
  else if(x<0){return(complex(real = 0, imaginary = sqrt(-x)))}
}
```


```{r, eval=FALSE}

# This function takes the complex square root of real numbers

general_sqrt <- function (x) {
  
  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(sqrt(x))
  } 
  
  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  } 
  
}

```

Clearly, the second example is a lot more readable and a lot easier to understand. Later, we'll talk about specific coding guidelines, but for now, just remember that the goal of programming style guides is to make your code *readable* and therefore *useable*. This will also make it a lot easier for others to fix and find bugs in your packaged code. 

### 2.2 Documentation

Of course, nobody wants to read through packaged code in order to guess what a function does. Instead, packages also include documentation to tell users how to use different functions and objects developed in the package. For exampe, imagine you typed '?scalep' into the Console and got the following result:

![*Documentation for scalep function*](Images/PackageSS/scalepdoc.PNG)

This documentation tells you what the scalep function does, what kinds of inputs it needs, what kind of output it returns, and gives you examples of how to use it. Documentation makes packages usable, and is suprisingly easy to write using devtools and roxygen2, so it's a critical part of any package. 

### 2.3 Description

The Description file of an R Package helps solve each one of the first three problems. It briefly outlines everything the package does, as well as the version of the pacakge and who maintains it. Perhaps most importantly for newer users, it also documents the dependencies of your package. For example, if you wrote a package which relies heavily on the boot package version 1.3-20, your description will document that, so your users don't have to spend hours searching for the exact package necessary to make your package work. 

### 2.4 Namespace 

- solves version control
- explain that some functions are imports/exports

Now that we've gone through the overall structure of packages, we'll walk you through what Grace *should* have done - the process of building an R package from start to finish. 

## 3. The Walkthrough

### Step 3.1: Initializing the Package

RStudio makes it easy to create packages. To start, click File>New Project. Then, click "New Directory" when you see the screen below:

![](Images/PackageSS/createproj1.PNG)

Then click "R Package" when you see the screen below:

![](Images/PackageSS/createproj2.PNG)

Lastly, title your package. Your title should be something short and descriptive. Since we'll be walking through a development example, we'll title our new package "devex."

![](Images/PackageSS/createproj3.PNG)

Once you've created your package, your RStudio should look something like this. It should come preloaded with a "Hello World" script which includes a handy function that prints "Hello world."

__ insert blank image of RStudio __

Everything should look mostly the same except for the "Files" tab on the bottom right, which should include an ".Rproj" file, a "DESCRIPTION" file, a "NAMESPACE" file, and a folder titled "R." You should start by checking the little boxes next to the "NAMESPACE" file and the "Hello.R" R script inside the R file and clicking "delete" above them, just because we will have Roxygen2 automatically generate the namespace, and because presumably your package doesn't need a "Hello World" function. Note that your directory section might not include a "man" file just yet - that's because you haven't generated any documentation yet, but that's okay!

You should also go to "Tools > Project Options" and select the following options, which will help you generate documentation and such using roxygen2: 

![](Images/PackageSS/userox.PNG)

### Step 3.2: Modifying the DESCRIPTION File

The DESCRIPTION file gives an extremely brief overview to the package. It includes critical information such as the author of the package, the title, a very short summary of its purpose, and the liscensing information. Double click on the "DESCRIPTION" file on in the files section to open and edit the DESCRIPTION tab. 

DESCRIPTION is a DCF file. This file format may be unfamiliar to you, but it's quite simple. Each line contains a a fieldname and value, separated by a colon. Sometimes, values are long enough to require multiple lines, in which case they are indented by four spaces. For example, the DESCRIPTION file for the devex package might look something like this:

![](Images/PackageSS/description.PNG)

Let's go through the fields and discuss what they mean. The first seven fields listed are mandatory, meaning that if you do not include them, the development environment will throw an error later on when you're trying to build your package. 

1. **Package**: This is the name of the package. It should match the package name you chose earlier, and you should probably just leave this as is. 
2. **Title**: A short but more descriptive title of your package than its name.
3. **Version**: The version of your package. Since you're creating this package for the first time, presumably it's version 0.1.0.
4. **Author**: Here, you should add in your name. 
5. **Maintainer**: Here, you should add in your name as well as a valid email enclosed in <> brackets. Note that if you do not enter a valid email, the development environment may throw errors later. 
6. **Description**: This should be a one-paragraph *comprehensive* description of the package. It is necessarily a high level-description, but it should be a complete one. 
7. **License**: You should add in a License, which describes how others can legally use the package. Most of the time (especially in the US), you should write 'CC0' in the License field, which implies that the package is open for all use, and you have relinquished all your rights to it. For more information on various licensing options, click [this link](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file).
  
(Note all of the fields from this point on are optional, but encouraged!)

8. **Type**: This describes what type of project you're creating - in this case, because you're creating a package, you should write "Package."
9. **Date**: The date, in YYYY-MM-DD fashion. 
10. **LazyData**: Write "true" after LazyData and the colon. Writing 'true' ensures that if you include any data with your package (which you frequently will), when another user loads your package, they won't automatically load up the data, but will only load it if it becomes necessary during their use. This option reduces the amount of RAM users have to expend when loading packages, especially if you are planning to include a lot of data with your package.
11. **Encoding**: Just leave this as "UTF-8"; discussing what encodings are isn't super important for this guide. If you're dying to learn about encodings, visit [this webpage](https://www.w3.org/International/questions/qa-what-is-encoding). 
12. **RoxygenNote**: Roxygen will automatically fill in the version of Roxygen2 used to build the package in this field. 

(These fields are exceptionally important if you are building a package using tools from other packages)

13. **Imports**: 
14. **Suggests**: 
15. **Depends**:

Should we add in functions that require imports/suggested? probably... 

### Step 3.3: Starting to Program

All of your code should be in scripts in the 'R' file created in the RStudio package development environment, as shown below:

![](Images/PackageSS/code1.PNG)

The coding you will do in package development is slightly different than the coding you'll normally do when writing R scripts. This is for a couple reasons:

1. When you write a script and load that script using source(script_name), the code in the script runs when you load it (specifically, when you run the 'source' command). On the other hand, the code in a package is run when the package is *built* on your computer. As a result, your code should mostly be focused on building functions, as opposed to a series of actions which the computer ought to take. 
2. Unlike your personal scripts, other people will be using your package, and if your package is good, they'll be using it in ways you didn't anticipate. This means you ought to really try to make sure your code is as general as possible and can support a variety of approaches and implementations. 

_examples_

You should also take care to organize your functions properly. It's probably a bad idea to stick them all into one script and title it "functions." Instead, you should organize functions by their purposes - for example, a variety of loss functions might go into a single script. Of course, some very complicated functions might deserve their own script. The file names of the script should be descriptive - for example, a script of loss functions might be named "loss_functions.R". 

Now let's talk about specific elements of code style. These are shortened and adapted from [Hadley Wickham's book on R package development](http://r-pkgs.had.co.nz/r.html), which in turn were adapted from Google's R style guide. For more advice on everything from naming variables to curly bracket placement, head to that aforementioned link.

1. **Comments**: Comments are the best (and easiest) way to make your code readable. In general, you err on the side of commenting too much rather than too little, and your comments should explain the *motivation* of your code as opposed to what your code actually does (although admittedly the line between those two things is a bit blurry). Moreover, you can use lines of '# ---------------------------' or '# ==================' to separate distinct sections of your code. Here's a good, if simple, example of commenting:

```{r}

# This function returns the squared difference element-wise between two vectors

loss <- function(x,y) {

  error <- (x-y)**2

  return(error)
}

#---------------------------------------------------------------------------

# Takes the square root of any real number, returning a complex number

general_sqrt <- function (x) {

  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(complex(real=sqrt(x), imaginary=0))
  }

  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  }

}
```

2. **Names**: Naming variables and functions is tricky - names should be descriptive but concise, and variable names should generally be nouns whereas function names tend to be verbs. Moreover, most R developers keep their function/variable names all lowercase and separate multiple words with underscores. There are no strict rules on this, but at the very least it's nice to be consistent with *some* rules because it makes your code more readable.

```{r, eval = FALSE}
# Bad example - function name
f <- function(x) {
  return(sqrt(x))
}

# Good example - function name
take_sqrt <- function(x){
  return(sqrt(x))
}

# Bad example - variable name
s <- read.table(path)

# Good example - variable name
car_data <- read.table(path)

```

3. **Spacing**: In general, you should use a lot of spaces, because they make your code a lot more readable! Specifically, you should always surround parenthesis with spaces; the exception is when you're making a function call. Note that this means you should surround the parenthesis themselves with spaces, but not the objects within the parenthesis, which should *not* be surrounded with spaces. You should also surround operators (like +, -, <-, =, /, **, others, etc) with spaces; see the examples below.

```{r, eval = FALSE}
# Bad examples of parenthesis spacing

if(a == 7)do(something) # Needs spaces before/after the parenthesis
if ( a == 7 ) # Shouldn't be spaces around 'a == 7'
function_call (parameter) # Shouldn't be a space between function_call and (parameter)

# Good example of parenthesis spacing

if (a == 7) do(something)
function_call(parameter)

# Bad example of operator spacing

a<-a+3 # Needs spaces 

# Good example of operator spacing

a <- a + 3


```

4. **Curly Braces**: You should start a new line after you write an opening curly brace, and ending curly braces should get their own lines, unless you have an else clause. 

```{r, eval = FALSE}
# Bad examples

if (condition) {
  do (x)} # Ending curly brace should get a new line

if (condition) { do(x) }

if (condition) {
  do(x)
}         # The else should be on this line
else {
  do(y)   # Should be indented with two spaces
}


# Good examples

if (condition) {
  do(x)
} else {
  do(y)
}

```

As always, you can break the rules if you have a good reason to. For example, the extra indentation in the following example helps maintain alignment and increases the readability of the code. 

```{r, eval = FALSE}
# Exception which proves the rule - the alignment improves readability
my_function = function(argument_1 = 'this string is extremely long',
                       argument_2 = 'this string is even longer somehow',
                       argument_3 = 'this string is also pretty long') {
  
}
```


Overall, different organizations and programmers have different styles and guidelines for specific coding style. Some programming guides might require you to avoid [camelCase](http://wiki.c2.com/?CamelCase); others might mandate its use. We've tried to document some pretty broadly accepted norms, but in general, you should remember:

1. Your goal should always be to make your code readable!
2. Whatever style guide you follow, following it *consistently* is key to making your code readable
3. You should generally adapt to follow the conventions of the organization you're working under/for

### Step 3.4: Documenting your package

(Note: here, we describe how to document functions. For a more detailed description of how to document S3, S4, and reference classes, check out [this page](http://r-pkgs.had.co.nz/man.html).)

Creating documentation for your package is incredibly easy with Roxygen2. The first thing to do, if you haven't already done it, is to install and load roxygen2 (as documented in the RStudio guidelines page), and then to check the options demonstrated at the end of Step 3.1 in this file.

When you write documentation with roxygen2, the final product should look something like this, which generates the documentation for the "general_sqrt" function above. 

```{r, eval=FALSE}

#' Generalized Square Roots
#'
#' \code{general_sqrt} returns the square root of any real number
#'
#' @param x A real number - integers or doubles are both acceptable.
#' @return A complex value. If x is positive, the imaginary component is equal to 0;
#' if x is negative, the real component is equal to 0.
#'
#' @examples
#' general_sqrt(10)
#' general_sqrt(-10)
#' general_sqrt(-1)
#'
#' @export
# This function takes the complex square root of real numbers

general_sqrt <- function (x) {

  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(complex(real=sqrt(x), imaginary=0))
  }

  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  }

}
```

![](Images/PackageSS/gensqrtdoc.PNG)

Note that inside the R script, the documentation appears right above the definition of the function - this is helpful because it will help you remember to keep your documentations/functions up to date with each other. Let's work through how this documentation was generated.

1. Note that everything you write in Roxygen2 should be preceded by a #' character combo. This signals to the RStudio environment that you're writing documentation, not code. 

2. You should start your documentation with a very short (2-4 word) title of the function. In the example given above, the "general_sqrt" function is titled "Generalized Square Roots." 

3. You should describe your functions' parameters using the '@param' signifier. This should succintly describe the type (i.e. double, integer, character) of the parameter, as well as its function, as well as any potential default value. 

4. You should document the type of output your function returns. Is it an integer, a dataframe, a matrix? Does it depend on the input? Your documentation should answer these questions!

5. You *must* provide examples of your function's use. These are pretty critical, because a lot of programmers will just skip straight to the examples (and only look at the rest of the documentation if the examples are unclear). 

6. You may choose to write '@export' at the end of your documentation block. You should only do this if you want other people to use the function that you're exporting, because exporting it will make sure it shows up in the namespace. Most functions you write won't be exported - for example, if you write a helper function like 'loss' which is only used in service of a larger function, it shouldn't be exported (exporting too many functions 'clutters' the namespace). Normally, a function as simple as 'general_sqrt' probably wouldn't be exported, but we have exported it for the sake of providing a simple examption. 

## Step 5: Building Your Package

Sources cited:

http://r-pkgs.had.co.nz/intro.html
